# Stable

#### Проблемы

1. Потеря пакетов
    - Каждый пакет должен иметь свой номер и:
        - либо в себе иметь номер следующего пакета
        - либо номера пакетов должны создаваться по синхронному алгоритму

2. Различные скажение байтов
    - должна быть простая чек-сумма, чтобы минимизировать вероятность ошибки в ней
    - после чек-суммы (например кол-во четных байтов и кол-во нечетных) должна идти хэш-сумма
      для проверки целостности содержимого
    - в каждый пакет должен быть включен размер (а надо ли?)

3. Перемешивание пакетов на отправку/отправление
    - решение такое же, как и при потере пакетов

### Инфраструктура для решений таких проблем

##### *Нормальный сценарий*

1. Создание пакета и его отправка серверу
pack1:
    - bsum: 12;37      # Byte-сумма even/odd _остального_ пакета
    - hash: abc123     # Hash-сумма _остального_ пакета, включая байт-сумму
    - flag: 0          # Флаг пакета (0 - general, 1 - resend after failure, 2 - please packet retry, 3 - cuid missmatch, 4 - uid linked wrong)
    - cuid: 928        # UID подключения (клиента), используется вместо адреса
    - uid: 1234        # UID пакета
    - nuid: 567        # UID следующего пакета
    - body: Hello!     # Тело запроса, основная информация

2. Проверка пакета сервером

    1. bsum = 12, 37
    => кол-во odd/even байтов в пакете, всё совпадает

    2. hash = abc123
    => hash остального содержимого, вкл. byte-сумму

    3. сuid = 928 
    => т.к. до этого пакетов от этого адресата не было, создается новое подключение

    4. uid = 1234
    => т.к. это новое подключение, предыдущий uid неизвестен, поэтому он принимается, как данное

    5. nuid = 567
    => создается запись для подключения `928`, что следующий пакет должен быть под
       номером 567
    
    6. body = "Hello!"
    => т.к. все проверки пройдены, то это действительно то, что отправил клиент

3. Отправка пакета сервером клиенту в качестве ответа
pack-ans1:
    - bsum: 43;13      # Byte-сумма even/odd _остального_ пакета
    - hash: abc567     # Hash-сумма _остального_ пакета, включая байт-сумму
    - cuid: 928        # UID подключения (клиента), используется вместо адреса
    - uid: 1234        # UID пакета для ответа
    - nuid: 567        # UID следующего ответного пакета
    - body: Echo!      # Тело запроса, основная информация

4. Клиент получает пакет и проверяет

    1. bsum = 43, 13
    => кол-во odd/even байтов в пакете, всё совпадает

    2. hash = abc123
    => hash остального содержимого, вкл. byte-сумму

    3. сuid = 928 
    => такое соединение действительно существует

    4. uid = 1234
    => последний отправленный пакет был под номером `1234`, поэтому ок

    5. nuid = 567
    => т.к. для последнего отправленного пакета nuid == `567` всё ок
    
    6. body = "Echo!"
    => т.к. все проверки пройдены, то это действительно то, что ответил сервер

##### *Сценарий с искажением данных*

**Если не совпадают byte-sum и/или hash-sum'мы:**

1. На стороне клиента (S1 -> crack -> C1)
pack2 (C1->S1):
    - bsum: 7;6        
    - hash: abc423     
    - flag: 2          # flag 2 => просьба переслать пакет заново
    - cuid: 928        # UID клиента
    - nuid: 1234       # UID неудавшегося пакета

2. Прием на стороне сервера (S1 -> crack -> C1 -> S1)

При приеме пакета с `flag = 2` сервер понимает, что при передаче от него были ошибки в байтах

3. Не смотря на то, что пакет с номером cuid-uid уже отправлены, из-за флага `2`, осуществляется _повторная отправка_ 
Однако пакет в данном случае с флагом `1`

Такой цикл продолжается, пока `flag` == `2`

**!Если двойная поломка**
1. На стороне клиента И сервера (S1 -> crack -> C1)
pack2 (C1->S1):
    - bsum: 7;6        
    - hash: abc423     
    - flag: 2          # flag 2 => просьба переслать пакет заново
    - cuid: 928        # UID клиента
    - nuid: 1234       # UID неудавшегося пакета

2. Прием на стороне сервера (S1 -> crack -> C1 -> crack -> S1)
На стороне сервера создается пакет с флагом `2` и отправляется клиенту

Такой цикл продолжается, пока `flag` == `2`

**Если не совпадают cuid/uid (flag = 3, 4)**

1. Если от сервера пришел ответ с неверным uid и/или nuid, то юзер отправляет пакет:
- с флагом 3 (если cuid не совпадает)
- с флагом 4 (если uid/nuid не совпадает)

Сервер следует такому же алгоритму с пакетами пользователей

2. Если в ответ приходит пакет с флагми 3-4
сокет (не важно, сервер или клиент) ждут `delta_time` и пробуют ещё раз